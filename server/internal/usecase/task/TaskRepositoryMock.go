// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package task

import (
	"context"
	"github.com/HoangVyDuong/togo/internal/storages/task"
	"sync"
)

var (
	lockRepositoryMockAddTask        sync.RWMutex
	lockRepositoryMockRetrieveTasks  sync.RWMutex
	lockRepositoryMockSoftDeleteTask sync.RWMutex
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//     func TestSomethingThatUsesRepository(t *testing.T) {
//
//         // make and configure a mocked Repository
//         mockedRepository := &RepositoryMock{
//             AddTaskFunc: func(ctx context.Context, taskEntity task.Task) (int64, error) {
// 	               panic("mock out the AddTask method")
//             },
//             RetrieveTasksFunc: func(ctx context.Context, userId int64) ([]task.Task, error) {
// 	               panic("mock out the RetrieveTasks method")
//             },
//             SoftDeleteTaskFunc: func(ctx context.Context, taskId int64) error {
// 	               panic("mock out the SoftDeleteTask method")
//             },
//         }
//
//         // use mockedRepository in code that requires Repository
//         // and then make assertions.
//
//     }
type RepositoryMock struct {
	// AddTaskFunc mocks the AddTask method.
	AddTaskFunc func(ctx context.Context, taskEntity task.Task) (int64, error)

	// RetrieveTasksFunc mocks the RetrieveTasks method.
	RetrieveTasksFunc func(ctx context.Context, userId int64) ([]task.Task, error)

	// SoftDeleteTaskFunc mocks the SoftDeleteTask method.
	SoftDeleteTaskFunc func(ctx context.Context, taskId int64) error

	// calls tracks calls to the methods.
	calls struct {
		// AddTask holds details about calls to the AddTask method.
		AddTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskEntity is the taskEntity argument value.
			TaskEntity task.Task
		}
		// RetrieveTasks holds details about calls to the RetrieveTasks method.
		RetrieveTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserId is the userId argument value.
			UserId int64
		}
		// SoftDeleteTask holds details about calls to the SoftDeleteTask method.
		SoftDeleteTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskId is the taskId argument value.
			TaskId int64
		}
	}
}

// AddTask calls AddTaskFunc.
func (mock *RepositoryMock) AddTask(ctx context.Context, taskEntity task.Task) (int64, error) {
	if mock.AddTaskFunc == nil {
		panic("RepositoryMock.AddTaskFunc: method is nil but Repository.AddTask was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		TaskEntity task.Task
	}{
		Ctx:        ctx,
		TaskEntity: taskEntity,
	}
	lockRepositoryMockAddTask.Lock()
	mock.calls.AddTask = append(mock.calls.AddTask, callInfo)
	lockRepositoryMockAddTask.Unlock()
	return mock.AddTaskFunc(ctx, taskEntity)
}

// AddTaskCalls gets all the calls that were made to AddTask.
// Check the length with:
//     len(mockedRepository.AddTaskCalls())
func (mock *RepositoryMock) AddTaskCalls() []struct {
	Ctx        context.Context
	TaskEntity task.Task
} {
	var calls []struct {
		Ctx        context.Context
		TaskEntity task.Task
	}
	lockRepositoryMockAddTask.RLock()
	calls = mock.calls.AddTask
	lockRepositoryMockAddTask.RUnlock()
	return calls
}

// RetrieveTasks calls RetrieveTasksFunc.
func (mock *RepositoryMock) RetrieveTasks(ctx context.Context, userId int64) ([]task.Task, error) {
	if mock.RetrieveTasksFunc == nil {
		panic("RepositoryMock.RetrieveTasksFunc: method is nil but Repository.RetrieveTasks was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserId int64
	}{
		Ctx:    ctx,
		UserId: userId,
	}
	lockRepositoryMockRetrieveTasks.Lock()
	mock.calls.RetrieveTasks = append(mock.calls.RetrieveTasks, callInfo)
	lockRepositoryMockRetrieveTasks.Unlock()
	return mock.RetrieveTasksFunc(ctx, userId)
}

// RetrieveTasksCalls gets all the calls that were made to RetrieveTasks.
// Check the length with:
//     len(mockedRepository.RetrieveTasksCalls())
func (mock *RepositoryMock) RetrieveTasksCalls() []struct {
	Ctx    context.Context
	UserId int64
} {
	var calls []struct {
		Ctx    context.Context
		UserId int64
	}
	lockRepositoryMockRetrieveTasks.RLock()
	calls = mock.calls.RetrieveTasks
	lockRepositoryMockRetrieveTasks.RUnlock()
	return calls
}

// SoftDeleteTask calls SoftDeleteTaskFunc.
func (mock *RepositoryMock) SoftDeleteTask(ctx context.Context, taskId int64) error {
	if mock.SoftDeleteTaskFunc == nil {
		panic("RepositoryMock.SoftDeleteTaskFunc: method is nil but Repository.SoftDeleteTask was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TaskId int64
	}{
		Ctx:    ctx,
		TaskId: taskId,
	}
	lockRepositoryMockSoftDeleteTask.Lock()
	mock.calls.SoftDeleteTask = append(mock.calls.SoftDeleteTask, callInfo)
	lockRepositoryMockSoftDeleteTask.Unlock()
	return mock.SoftDeleteTaskFunc(ctx, taskId)
}

// SoftDeleteTaskCalls gets all the calls that were made to SoftDeleteTask.
// Check the length with:
//     len(mockedRepository.SoftDeleteTaskCalls())
func (mock *RepositoryMock) SoftDeleteTaskCalls() []struct {
	Ctx    context.Context
	TaskId int64
} {
	var calls []struct {
		Ctx    context.Context
		TaskId int64
	}
	lockRepositoryMockSoftDeleteTask.RLock()
	calls = mock.calls.SoftDeleteTask
	lockRepositoryMockSoftDeleteTask.RUnlock()
	return calls
}
