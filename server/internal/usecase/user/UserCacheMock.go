// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package user

import (
	"context"
	"sync"
	"time"
)

var (
	lockCacheMockIncreaseTask sync.RWMutex
	lockCacheMockIsOverLimit  sync.RWMutex
)

// Ensure, that CacheMock does implement Cache.
// If this is not the case, regenerate this file with moq.
var _ Cache = &CacheMock{}

// CacheMock is a mock implementation of Cache.
//
//     func TestSomethingThatUsesCache(t *testing.T) {
//
//         // make and configure a mocked Cache
//         mockedCache := &CacheMock{
//             IncreaseTaskFunc: func(ctx context.Context, userId string, duration time.Duration) (int, error) {
// 	               panic("mock out the IncreaseTask method")
//             },
//             IsOverLimitFunc: func(ctx context.Context, userKey string, limitTime int) (bool, error) {
// 	               panic("mock out the IsOverLimit method")
//             },
//         }
//
//         // use mockedCache in code that requires Cache
//         // and then make assertions.
//
//     }
type CacheMock struct {
	// IncreaseTaskFunc mocks the IncreaseTask method.
	IncreaseTaskFunc func(ctx context.Context, userId string, duration time.Duration) (int, error)

	// IsOverLimitFunc mocks the IsOverLimit method.
	IsOverLimitFunc func(ctx context.Context, userKey string, limitTime int) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// IncreaseTask holds details about calls to the IncreaseTask method.
		IncreaseTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserId is the userId argument value.
			UserId string
			// Duration is the duration argument value.
			Duration time.Duration
		}
		// IsOverLimit holds details about calls to the IsOverLimit method.
		IsOverLimit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserKey is the userKey argument value.
			UserKey string
			// LimitTime is the limitTime argument value.
			LimitTime int
		}
	}
}

// IncreaseTask calls IncreaseTaskFunc.
func (mock *CacheMock) IncreaseTask(ctx context.Context, userId string, duration time.Duration) (int, error) {
	if mock.IncreaseTaskFunc == nil {
		panic("CacheMock.IncreaseTaskFunc: method is nil but Cache.IncreaseTask was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		UserId   string
		Duration time.Duration
	}{
		Ctx:      ctx,
		UserId:   userId,
		Duration: duration,
	}
	lockCacheMockIncreaseTask.Lock()
	mock.calls.IncreaseTask = append(mock.calls.IncreaseTask, callInfo)
	lockCacheMockIncreaseTask.Unlock()
	return mock.IncreaseTaskFunc(ctx, userId, duration)
}

// IncreaseTaskCalls gets all the calls that were made to IncreaseTask.
// Check the length with:
//     len(mockedCache.IncreaseTaskCalls())
func (mock *CacheMock) IncreaseTaskCalls() []struct {
	Ctx      context.Context
	UserId   string
	Duration time.Duration
} {
	var calls []struct {
		Ctx      context.Context
		UserId   string
		Duration time.Duration
	}
	lockCacheMockIncreaseTask.RLock()
	calls = mock.calls.IncreaseTask
	lockCacheMockIncreaseTask.RUnlock()
	return calls
}

// IsOverLimit calls IsOverLimitFunc.
func (mock *CacheMock) IsOverLimit(ctx context.Context, userKey string, limitTime int) (bool, error) {
	if mock.IsOverLimitFunc == nil {
		panic("CacheMock.IsOverLimitFunc: method is nil but Cache.IsOverLimit was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		UserKey   string
		LimitTime int
	}{
		Ctx:       ctx,
		UserKey:   userKey,
		LimitTime: limitTime,
	}
	lockCacheMockIsOverLimit.Lock()
	mock.calls.IsOverLimit = append(mock.calls.IsOverLimit, callInfo)
	lockCacheMockIsOverLimit.Unlock()
	return mock.IsOverLimitFunc(ctx, userKey, limitTime)
}

// IsOverLimitCalls gets all the calls that were made to IsOverLimit.
// Check the length with:
//     len(mockedCache.IsOverLimitCalls())
func (mock *CacheMock) IsOverLimitCalls() []struct {
	Ctx       context.Context
	UserKey   string
	LimitTime int
} {
	var calls []struct {
		Ctx       context.Context
		UserKey   string
		LimitTime int
	}
	lockCacheMockIsOverLimit.RLock()
	calls = mock.calls.IsOverLimit
	lockCacheMockIsOverLimit.RUnlock()
	return calls
}
