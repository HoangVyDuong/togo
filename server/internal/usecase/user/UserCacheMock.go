// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package user

import (
	"context"
	"sync"
	"time"
)

var (
	lockCacheMockCheckLimit   sync.RWMutex
	lockCacheMockIncreaseTask sync.RWMutex
)

// Ensure, that CacheMock does implement Cache.
// If this is not the case, regenerate this file with moq.
var _ Cache = &CacheMock{}

// CacheMock is a mock implementation of Cache.
//
//     func TestSomethingThatUsesCache(t *testing.T) {
//
//         // make and configure a mocked Cache
//         mockedCache := &CacheMock{
//             CheckLimitFunc: func(ctx context.Context, userKey string, limitTime int) (bool, error) {
// 	               panic("mock out the CheckLimit method")
//             },
//             IncreaseTaskFunc: func(ctx context.Context, userId string, duration time.Duration) (int, error) {
// 	               panic("mock out the IncreaseTask method")
//             },
//         }
//
//         // use mockedCache in code that requires Cache
//         // and then make assertions.
//
//     }
type CacheMock struct {
	// CheckLimitFunc mocks the CheckLimit method.
	CheckLimitFunc func(ctx context.Context, userKey string, limitTime int) (bool, error)

	// IncreaseTaskFunc mocks the IncreaseTask method.
	IncreaseTaskFunc func(ctx context.Context, userId string, duration time.Duration) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// CheckLimit holds details about calls to the CheckLimit method.
		CheckLimit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserKey is the userKey argument value.
			UserKey string
			// LimitTime is the limitTime argument value.
			LimitTime int
		}
		// IncreaseTask holds details about calls to the IncreaseTask method.
		IncreaseTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserId is the userId argument value.
			UserId string
			// Duration is the duration argument value.
			Duration time.Duration
		}
	}
}

// CheckLimit calls CheckLimitFunc.
func (mock *CacheMock) CheckLimit(ctx context.Context, userKey string, limitTime int) (bool, error) {
	if mock.CheckLimitFunc == nil {
		panic("CacheMock.CheckLimitFunc: method is nil but Cache.CheckLimit was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		UserKey   string
		LimitTime int
	}{
		Ctx:       ctx,
		UserKey:   userKey,
		LimitTime: limitTime,
	}
	lockCacheMockCheckLimit.Lock()
	mock.calls.CheckLimit = append(mock.calls.CheckLimit, callInfo)
	lockCacheMockCheckLimit.Unlock()
	return mock.CheckLimitFunc(ctx, userKey, limitTime)
}

// CheckLimitCalls gets all the calls that were made to CheckLimit.
// Check the length with:
//     len(mockedCache.CheckLimitCalls())
func (mock *CacheMock) CheckLimitCalls() []struct {
	Ctx       context.Context
	UserKey   string
	LimitTime int
} {
	var calls []struct {
		Ctx       context.Context
		UserKey   string
		LimitTime int
	}
	lockCacheMockCheckLimit.RLock()
	calls = mock.calls.CheckLimit
	lockCacheMockCheckLimit.RUnlock()
	return calls
}

// IncreaseTask calls IncreaseTaskFunc.
func (mock *CacheMock) IncreaseTask(ctx context.Context, userId string, duration time.Duration) (int, error) {
	if mock.IncreaseTaskFunc == nil {
		panic("CacheMock.IncreaseTaskFunc: method is nil but Cache.IncreaseTask was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		UserId   string
		Duration time.Duration
	}{
		Ctx:      ctx,
		UserId:   userId,
		Duration: duration,
	}
	lockCacheMockIncreaseTask.Lock()
	mock.calls.IncreaseTask = append(mock.calls.IncreaseTask, callInfo)
	lockCacheMockIncreaseTask.Unlock()
	return mock.IncreaseTaskFunc(ctx, userId, duration)
}

// IncreaseTaskCalls gets all the calls that were made to IncreaseTask.
// Check the length with:
//     len(mockedCache.IncreaseTaskCalls())
func (mock *CacheMock) IncreaseTaskCalls() []struct {
	Ctx      context.Context
	UserId   string
	Duration time.Duration
} {
	var calls []struct {
		Ctx      context.Context
		UserId   string
		Duration time.Duration
	}
	lockCacheMockIncreaseTask.RLock()
	calls = mock.calls.IncreaseTask
	lockCacheMockIncreaseTask.RUnlock()
	return calls
}
