// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package user

import (
	"context"
	"sync"
	"time"
)

var (
	lockServiceMockIncreaseTaskTimesPerDuration sync.RWMutex
	lockServiceMockIsOverLimitTask              sync.RWMutex
)

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
//     func TestSomethingThatUsesService(t *testing.T) {
//
//         // make and configure a mocked Service
//         mockedService := &ServiceMock{
//             IncreaseTaskTimesPerDurationFunc: func(ctx context.Context, userId string, duration time.Duration) (int, error) {
// 	               panic("mock out the IncreaseTaskTimesPerDuration method")
//             },
//             IsOverLimitTaskFunc: func(ctx context.Context, userId string, limit int) (bool, error) {
// 	               panic("mock out the IsOverLimitTask method")
//             },
//         }
//
//         // use mockedService in code that requires Service
//         // and then make assertions.
//
//     }
type ServiceMock struct {
	// IncreaseTaskTimesPerDurationFunc mocks the IncreaseTaskTimesPerDuration method.
	IncreaseTaskTimesPerDurationFunc func(ctx context.Context, userId string, duration time.Duration) (int, error)

	// IsOverLimitTaskFunc mocks the IsOverLimitTask method.
	IsOverLimitTaskFunc func(ctx context.Context, userId string, limit int) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// IncreaseTaskTimesPerDuration holds details about calls to the IncreaseTaskTimesPerDuration method.
		IncreaseTaskTimesPerDuration []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserId is the userId argument value.
			UserId string
			// Duration is the duration argument value.
			Duration time.Duration
		}
		// IsOverLimitTask holds details about calls to the IsOverLimitTask method.
		IsOverLimitTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserId is the userId argument value.
			UserId string
			// Limit is the limit argument value.
			Limit int
		}
	}
}

// IncreaseTaskTimesPerDuration calls IncreaseTaskTimesPerDurationFunc.
func (mock *ServiceMock) IncreaseTaskTimesPerDuration(ctx context.Context, userId string, duration time.Duration) (int, error) {
	if mock.IncreaseTaskTimesPerDurationFunc == nil {
		panic("ServiceMock.IncreaseTaskTimesPerDurationFunc: method is nil but Service.IncreaseTaskTimesPerDuration was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		UserId   string
		Duration time.Duration
	}{
		Ctx:      ctx,
		UserId:   userId,
		Duration: duration,
	}
	lockServiceMockIncreaseTaskTimesPerDuration.Lock()
	mock.calls.IncreaseTaskTimesPerDuration = append(mock.calls.IncreaseTaskTimesPerDuration, callInfo)
	lockServiceMockIncreaseTaskTimesPerDuration.Unlock()
	return mock.IncreaseTaskTimesPerDurationFunc(ctx, userId, duration)
}

// IncreaseTaskTimesPerDurationCalls gets all the calls that were made to IncreaseTaskTimesPerDuration.
// Check the length with:
//     len(mockedService.IncreaseTaskTimesPerDurationCalls())
func (mock *ServiceMock) IncreaseTaskTimesPerDurationCalls() []struct {
	Ctx      context.Context
	UserId   string
	Duration time.Duration
} {
	var calls []struct {
		Ctx      context.Context
		UserId   string
		Duration time.Duration
	}
	lockServiceMockIncreaseTaskTimesPerDuration.RLock()
	calls = mock.calls.IncreaseTaskTimesPerDuration
	lockServiceMockIncreaseTaskTimesPerDuration.RUnlock()
	return calls
}

// IsOverLimitTask calls IsOverLimitTaskFunc.
func (mock *ServiceMock) IsOverLimitTask(ctx context.Context, userId string, limit int) (bool, error) {
	if mock.IsOverLimitTaskFunc == nil {
		panic("ServiceMock.IsOverLimitTaskFunc: method is nil but Service.IsOverLimitTask was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserId string
		Limit  int
	}{
		Ctx:    ctx,
		UserId: userId,
		Limit:  limit,
	}
	lockServiceMockIsOverLimitTask.Lock()
	mock.calls.IsOverLimitTask = append(mock.calls.IsOverLimitTask, callInfo)
	lockServiceMockIsOverLimitTask.Unlock()
	return mock.IsOverLimitTaskFunc(ctx, userId, limit)
}

// IsOverLimitTaskCalls gets all the calls that were made to IsOverLimitTask.
// Check the length with:
//     len(mockedService.IsOverLimitTaskCalls())
func (mock *ServiceMock) IsOverLimitTaskCalls() []struct {
	Ctx    context.Context
	UserId string
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		UserId string
		Limit  int
	}
	lockServiceMockIsOverLimitTask.RLock()
	calls = mock.calls.IsOverLimitTask
	lockServiceMockIsOverLimitTask.RUnlock()
	return calls
}
